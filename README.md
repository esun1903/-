# 운영체제

- 컴퓨터 시스템의 자원들을 효율적으로 관리하며 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임이다.
 - 컴퓨터사용자와 컴퓨터 하드웨어 간의 인터페이스로서 동작하는 시스템 소프트웨어의 일종으로, 다른 응용 프로그램이 유용한 작업을 할 수 있도록 환경을 제공해준다.
- 하드웨어를 제어하는 소프트웨어
- 응용프로그램이 하드웨어와 상호 작용할 수 있게 해주는 소프트웨어이다.

## 운영체제의 목적
 - 처리능력(Throughput): 일정 시간 내에 시스템이 처리하는 일의 양
 - 반환시간(Turn Around Time): 시스템에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간
 - 사용가능도(Availability) : 시스템을 사용할 필요가 있을 때 즉시 사용 가능한 정도
 - 신뢰도(Reliability): 시스템이 주어진 문제를 정확하게 해결하는 정도
## 세마포어, 뮤텍스
   -> 프로세스 간 메시지를 전송하거나, 공유메모리를 통해 특정데이터를 공유하게 되는 경우  ---------> 문제가 생김
      
       즉, 공유된 자원에서 여러 개의 프로세스가 동시에 접근하면서 문제가 발생 ->  이것을 제한하는 것이 세마포어
   
## 세마포어 : 여러 공유된 자원의 데이터를 여러 프로세스가 접근하는 것을 맞는 
## 뮤텍스 : 공유된 자원의 데이터를 여러 쓰레드가 접근하는 것을 막는 

         세마포어 : 프로세스 , 뮤텍스 : 쓰레드
         
### 뮤텍스 : locking , unlocking 
### 세마포어 : 값에 따라 달라짐

### 차이점들 
      -> Semaphore 는 mutex가 될 수 있따. 
         But, mutex는 Semaphore가 될 수 없다. 
         
         Semaphoere는 소유가 없다. 
         Mutex는 소유가 됨 
         
         가장 큰 차이점은 동기화 대상 
       
## DB

 ### ORM(Object Relational Mapping)
  
  객체와 관계와의 설정
  객체와 관계형 DB를 Mapping해준다.
  객체와 테이블을 Mapping하기 때문에 SQL을 직접 날리는 것이 아니라 마치 자바에서 라이브러리 사용하듯이 사용하면 된다.
  객체와 관계형 데이터에비스와의 설정을 자동으로 해준다.
  관계형 데이터베이스의 데이터를 객체형 데이터처럼 사용할 수 있다.

### JPA, Hibernate, MyBatis

 장점
 객체 지향적인 코드로 인해 더 직관적이고 비즈니스 로직에 집중할 수 있게 도와준다.
 선언, 할당, 종료 같은 부수적인 코드가 줄어든다.
 재사용 및 유지 보수의 편리성이 증가한다.
 DBMS에 대한 종속성이 줄어든다.
 절차적, 순차적 접근이 아닌 객체 지향적 접근으로 인해 생산성이 증가한다.

 단점
 모든 기능을 ORM으로만 작성하기에는 쿼리가 복잡해지면 쓰기 어렵다.
 많은 수의 레코드를 잦은 빈도로 벌크 수행
 ORM으로만 완벽하게 서비스를 구현하기가 어렵다.
 프로시저가 많은 시스템에선 ORM의 객체 지향적인 장점을 활용하기 어렵다.
 
 MySQL 엔진
 InnoDB
 
 기본값 스토리지 엔진
 트랜잭션 safe, 커밋과 롤백, 데이터 복구 기능을 제공한다.
 row-level locking을 제공한다.
 데이터를 clusterd index에 저장하여 pk기반 query의 I/O 비용을 줄인다.
 fk제약을 제공하여 데이터 무결성을 보장한다.
 
 MyISAM
 트랜잭션을 지원하지 않는다.
 테이블 단위의 locking을 제공한다.
 특정 세션이 테이블을 변경하는 동안 테이블 단위로 lock이 잡힌다.

 Archive
 로그 수집에 적합한 엔진
 데이터가 메모리 상에서 압축되고 압축된 상태로 디스크에 저장된다.
 row-level locking이 가능하다.
 한번 insert된 데이터는 update/delete가 불가능하다.
 인덱스를 지원하지 않는다.
 거의 가공하지 않을 윈시 로그 데이터를 관리하는데 효율적이고, 테이블 파티셔닝도 지원한다.
 트랜잭션은 지원하지 않는다.

 ### 인덱스
 RDBMS에서 검색 속도를 높이기 위해 사용하는 기술

 ### 색인
 해당 테이블의 컬럼을 색인화(따로 파일로 저장)하여 검색시 테이블 전체를 full scan 하는 것이 아니라 색인화 되어있는 index 파일을 검색하여 검색 속도 를 빠르게 한다. 
 B+ 트리로 저장된다.
 index로 설정한 컬럼 값이 변경되거나 추가되면, 인덱스 역시 변경된다. 따라서 적절하게 인덱스를 설정해야 한다.
 데이터의 삽입, 삭제가 빈번한 경우 index의 성능이 떨어진다. 매번 B+트리를 수정해야 하기 때문이다.
 index가 데이터베이스 공간을 차지하기 때문에 추가적인 공간이 필요하다.(10%)
 index는 B+ 트리에서 key값으로 column의 값을 저장하고 있기 때문에 SELECT 조회 시 index로 설정한 데이터만 조회한다면 테이블을 조회하지 않고 인덱스  만 조회한다. (covering index)
 index를 생성하는데 시간이 많이 소요될 수 있다.
 SELECT의 WHERE / JOIN / GROUP BY 시에만 인덱스가 사용되며 SELECT의 검색 속도를 빠르게 하는것이 목적이다.
 WHERE의 타겟이 되는 컬럼을 인덱스로 만드는 것이 좋다.
 데이터 중복도가 높은 컬럼은 인덱스로 만들어도 효과가 없다.
 외래키가 사용되는 컬럼은 인덱스를 생성해 주는 것이 좋다.
 사용하지 않는 인덱스는 제거하는 것이 좋다.

### 정규화
관계형 데이터베이스의 설계에서 중복을 최소화하게 데이터를 구조화 하는 프로세스이다.
관계를 재구성하여 작고 잘 조직된 관계를 생성하는 것에 있다.
성능상의 이유로 비정규화 될 수 있다.
         

## DB Isolation Level
  격리성 관련 문제점

 #### 1.Dirty Read
 커밋되지 않은 수정 중인 데이터를 다른 트랜잭션에서 읽을 수 있도록 허용할 때 발생하는 현상이다.
 어떤 트랜잭션에서 아직 실행이 끝나지 않은 다른 트랜잭션에 의해 변경 사항을 보게 되는 경우이다.
 #### 2.Non-Repeatable Read
 한 트랜잭션에서 같은 SQL을 두 번 수행할 때, 두 SQL의 결과가 다르게 나타나는 비 일관적인 현상이다.
 한 트랜잭션이 수행중일 때 다른 트랜잭션이 값을 수정, 삭제함으로써 나타난다.
 #### 3.Phantom Read
 한 트랜잭션에서 같은 SQL을 두 번 수행할 때, 첫번째 SQL에서 없던 데이터가 두번째 SQL에서 나타나는 현상이다.
 한 트랜잭션이 수행중일 때 다른 트랜잭션이 값을 삽입함으로써 나타난다.
 
 
 
 
 
